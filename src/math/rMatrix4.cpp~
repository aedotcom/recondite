#include "rMatrix4.hpp"
#include "rMathUtil.hpp"

const rMatrix4 rMatrix4::IdentityMatrix = rMatrix4();

rMatrix4::rMatrix4(){
	LoadIdentity();
}


void rMatrix4::LoadIdentity(){
	memset(this , 0 , sizeof(rMatrix4) );
	SetUniformScale(1);
}


void rMatrix4::SetUniformScale(float k){
	m[0] = k;
	m[5] = k;
	m[10] = k;
	m[15] = k;
}


rVector3 rMatrix4::GetTranslate() const{
	return rVector3(m[12] , m[13] , m[14]);
}


void rMatrix4::SetTranslate (float tx, float ty , float tz){
	m[12] = tx;
	m[13] = ty;
	m[14] = tz;
}


void rMatrix4::SetTranslate (const rVector3& t){
	SetTranslate(t.x , t.y , t.z);
}


rVector3 rMatrix4::GetTransformedVector3(const rVector3& v) const{
	rVector3 r = v;
	TransformVector3(r);
	return r;
}


void rMatrix4::TransformVector3(rVector3& v)const{
	rVector3 r;
	r.x = m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12];
	r.y = m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13];
	r.z = m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14];
	v = r;
}


float rMatrix4::Determinant() const{
return      m[12] * m[9] * m[6] * m[3]-m[8] * m[13] * m[6] * m[3]-m[12] * m[5] * m[10] * m[3]+m[4] * m[13] * m[10] * m[3]+
      m[8] * m[5] * m[14] * m[3]-m[4] * m[9] * m[14] * m[3]-m[12] * m[9] * m[2] * m[7]+m[8] * m[13] * m[2] * m[7]+
      m[12] * m[1] * m[10] * m[7]-m[0] * m[13] * m[10] * m[7]-m[8] * m[1] * m[14] * m[7]+m[0] * m[9] * m[14] * m[7]+
      m[12] * m[5] * m[2] * m[11]-m[4] * m[13] * m[2] * m[11]-m[12] * m[1] * m[6] * m[11]+m[0] * m[13] * m[6] * m[11]+
      m[4] * m[1] * m[14] * m[11]-m[0] * m[5] * m[14] * m[11]-m[8] * m[5] * m[2] * m[15]+m[4] * m[9] * m[2] * m[15]+
      m[8] * m[1] * m[6] * m[15]-m[0] * m[9] * m[6] * m[15]-m[4] * m[1] * m[10] * m[15]+m[0] * m[5] * m[10] * m[15];
}


void rMatrix4::Invert(){
	float det = Determinant();
	if (det == 0.0)
		return;

	rMatrix4 result;

	result.m[0] = m[9]*m[14]*m[7] - m[13]*m[10]*m[7] + m[13]*m[6]*m[11] - m[5]*m[14]*m[11] - m[9]*m[6]*m[15] + m[5]*m[10]*m[15];
	result.m[1] = m[13]*m[10]*m[3] - m[9]*m[14]*m[3] - m[13]*m[2]*m[11] + m[1]*m[14]*m[11] + m[9]*m[2]*m[15] - m[1]*m[10]*m[15];
	result.m[2] = m[5]*m[14]*m[3] - m[13]*m[6]*m[3] + m[13]*m[2]*m[7] - m[1]*m[14]*m[7] - m[5]*m[2]*m[15] + m[1]*m[6]*m[15];
	result.m[3] = m[9]*m[6]*m[3] - m[5]*m[10]*m[3] - m[9]*m[2]*m[7] + m[1]*m[10]*m[7] + m[5]*m[2]*m[11] - m[1]*m[6]*m[11];
	   
	   
	result.m[4] = m[12]*m[10]*m[7] - m[8]*m[14]*m[7] - m[12]*m[6]*m[11] + m[4]*m[14]*m[11] + m[8]*m[6]*m[15] - m[4]*m[10]*m[15];
	result.m[5] = m[8]*m[14]*m[3] - m[12]*m[10]*m[3] + m[12]*m[2]*m[11] - m[0]*m[14]*m[11] - m[8]*m[2]*m[15] + m[0]*m[10]*m[15];
	result.m[6] = m[12]*m[6]*m[3] - m[4]*m[14]*m[3] - m[12]*m[2]*m[7] + m[0]*m[14]*m[7] + m[4]*m[2]*m[15] - m[0]*m[6]*m[15];
	result.m[7] = m[4]*m[10]*m[3] - m[8]*m[6]*m[3] + m[8]*m[2]*m[7] - m[0]*m[10]*m[7] - m[4]*m[2]*m[11] + m[0]*m[6]*m[11];
			 
	result.m[8] = m[8]*m[13]*m[7] - m[12]*m[9]*m[7] + m[12]*m[5]*m[11] - m[4]*m[13]*m[11] - m[8]*m[5]*m[15] + m[4]*m[9]*m[15];
	result.m[9] = m[12]*m[9]*m[3] - m[8]*m[13]*m[3] - m[12]*m[1]*m[11] + m[0]*m[13]*m[11] + m[8]*m[1]*m[15] - m[0]*m[9]*m[15];
	result.m[10] = m[4]*m[13]*m[3] - m[12]*m[5]*m[3] + m[12]*m[1]*m[7] - m[0]*m[13]*m[7] - m[4]*m[1]*m[15] + m[0]*m[5]*m[15];
	result.m[11] = m[8]*m[5]*m[3] - m[4]*m[9]*m[3] - m[8]*m[1]*m[7] + m[0]*m[9]*m[7] + m[4]*m[1]*m[11] - m[0]*m[5]*m[11];
	   
	result.m[12] = m[12]*m[9]*m[6] - m[8]*m[13]*m[6] - m[12]*m[5]*m[10] + m[4]*m[13]*m[10] + m[8]*m[5]*m[14] - m[4]*m[9]*m[14];
	result.m[13] = m[8]*m[13]*m[2] - m[12]*m[9]*m[2] + m[12]*m[1]*m[10] - m[0]*m[13]*m[10] - m[8]*m[1]*m[14] + m[0]*m[9]*m[14];
	result.m[14] = m[12]*m[5]*m[2] - m[4]*m[13]*m[2] - m[12]*m[1]*m[6] + m[0]*m[13]*m[6] + m[4]*m[1]*m[14] - m[0]*m[5]*m[14];
	result.m[15] = m[4]*m[9]*m[2] - m[8]*m[5]*m[2] + m[8]*m[1]*m[6] - m[0]*m[9]*m[6] - m[4]*m[1]*m[10] + m[0]*m[5]*m[10];

	result *= (1.0f / det);

	*this = result;
}


rMatrix4 rMatrix4::GetInvertedMatrix()const{
	rMatrix4 r = *this;
	r.Invert();
	return r;
}


rMatrix4& rMatrix4::operator *=(float k){
	m[0] *= k;	m[4] *= k;	m[8] *= k;	m[12] *= k;
	m[1] *= k;	m[5] *= k;	m[9] *= k;	m[13] *= k;
	m[2] *= k;	m[6] *= k;	m[10] *= k;	m[14] *= k;
	m[3] *= k;	m[7] *= k;	m[11] *= k;	m[15] *= k;

	return *this;
}

void rMatrix4::SetRotationBetweenVectors(const rVector3& vA, const rVector3& vB){
    float cos_angle = vA.Dot(vB);
    float sin_angle = std::sqrt (1.0f - cos_angle * cos_angle);
    float one_minus_cos = 1.0f - cos_angle;

    rVector3 axis = vA.Cross(vB);

    m[0] = 1.0f + one_minus_cos * (axis.x * axis.x - 1.0f);
    m[1] = axis.z * sin_angle + one_minus_cos * axis.x * axis.y;
    m[2] = -axis.y * sin_angle + one_minus_cos * axis.x * axis.z;

    m[4] = -axis.z * sin_angle + one_minus_cos * axis.x * axis.y;
    m[5] = 1.0f + one_minus_cos * (axis.y * axis.y - 1.0f);
    m[6] = axis.x * sin_angle + one_minus_cos * axis.y * axis.z;

    m[8] = axis.y * sin_angle + one_minus_cos * axis.x * axis.z;
    m[9] = -axis.x * sin_angle + one_minus_cos * axis.y * axis.z;
    m[10] = 1.0f + one_minus_cos * (axis.z * axis.z - 1.0f);
}