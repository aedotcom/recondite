#include "rRenderer.hpp"

rRenderer::rRenderer(rGraphicsDevice* graphicsDevice){
	m_graphicsDevice = graphicsDevice;
	m_isRendering = false;
}

rRenderer::~rRenderer(){
	ClearCommands();
}

void rRenderer::Begin(){
	ClearCommands();
	m_isRendering = true;
}

void rRenderer::End(){
	m_isRendering = false;
}

void rRenderer::Render(rDrawable* drawable, rRenderMode mode){
	if (!m_isRendering)
		return;

	SetRenderMode(mode);
	drawable->Draw(this);
}

void rRenderer::DrawRectangle(const rRectangle2& rectangle,const rColor& color, rRenderMode mode){
	rRectangle2RenderCommand* command = new rRectangle2RenderCommand( (mode != rRENDER_DEFAULT) ? mode : m_currentMode, color , rectangle);
	m_commands.push_back(command);

}

void rRenderer::DrawCircle(const rCircle2& circle,const rColor& color, rRenderMode mode){
	rCircle2RenderCommand* command = new rCircle2RenderCommand((mode != rRENDER_DEFAULT) ? mode : m_currentMode, color , circle);
	m_commands.push_back(command);
}

void rRenderer::DrawPoint(const rVector2& point , const rColor& color, rRenderMode mode){
	rVector2PointRenderCommand* command = new rVector2PointRenderCommand((mode != rRENDER_DEFAULT) ? mode : m_currentMode, color , point);
	m_commands.push_back(command);
}

void rRenderer::DrawLines(rFloatArray& lines , const rColor& color, rRenderMode mode){
	rLineRenderCommand* command = new rLineRenderCommand(lines , color);
	m_commands.push_back(command);
}

void rRenderer::DrawLines3(rVector3Array& lines , const rColor& color){
	rLines3RenderCommand* command = new rLines3RenderCommand(color , lines);
	m_commands.push_back(command);
}

void rRenderer::DrawTriangle(const rTriangle2& triangle , const rColor& color, rRenderMode mode){
	rTriangleRenderCommand* command = new rTriangleRenderCommand((mode != rRENDER_DEFAULT) ? mode : m_currentMode, color, triangle);
	m_commands.push_back(command);
}

void rRenderer::DrawAlignedBox(const rAlignedBox3& box , const rColor& color , rRenderMode mode){
	rAlignedBox3RenderCommand* command = new rAlignedBox3RenderCommand((mode != rRENDER_DEFAULT) ? mode : m_currentMode, color, box);
	m_commands.push_back(command);
}

void rRenderer::DrawPoint3(const rVector3& point , const rColor& color, rRenderMode mode){
	rPoint3RenderCommand* command = new rPoint3RenderCommand(color , point);
	m_commands.push_back(command);
}

void rRenderer::DrawSphere(const rSphere3& sphere , const rColor& color , rRenderMode mode){
	rSphere3RenderCommand* command = new rSphere3RenderCommand(mode , color , sphere);
	m_commands.push_back(command);
}

void rRenderer::DrawCone3(const rCone3& cone , const rColor& color, rRenderMode mode){
    rCone3RenderCommand* command = new rCone3RenderCommand(mode , color , cone);
    m_commands.push_back(command);
}

void rRenderer::DrawLineSegment3(const rLineSegment3& segment , const rColor& color){
    rLineSegment3RenderCommand* command = new rLineSegment3RenderCommand(color , segment);
    m_commands.push_back(command);
}

void rRenderer::ExecuteCommands(){
	for (size_t i = 0; i < m_commands.size(); i++)
		m_commands[i]->Render(m_graphicsDevice);
}

void rRenderer::ClearCommands(){

	for (size_t i = 0; i < m_commands.size(); i++)
		delete m_commands[i];

	m_commands.clear();
}