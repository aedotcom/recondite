#include "rGraphicsDevice.hpp"

rGraphicsDevice::rGraphicsDevice(){
	InitCircle();
	InitRectangle();
	InitBox();
	InitSphere();
	InitCone();
}

rGraphicsDevice::~rGraphicsDevice(){
}



void rGraphicsDevice::InitSphere(){

	unsigned short index = 0;
	float thetaStep = 360.0f / (float)rqtSPHERE_STACKS;
	float phiStep = 360.0f / (float)rqtSPHERE_SEGMENTS;
	rVector3 controlPoint;

	for (float theta = -90.0f; theta <= 90.0f - thetaStep; theta += thetaStep){

		for (float phi = 0.0f; phi <= 360.0f - phiStep; phi += phiStep){
			controlPoint.Set(	std::cos(rMath::DegreeToRad(theta)) * std::cos(rMath::DegreeToRad(phi)),
								std::cos(rMath::DegreeToRad(theta)) * std::sin(rMath::DegreeToRad(phi)),
								std::sin(rMath::DegreeToRad(theta)));
			spherePoints.push_back(controlPoint);

			controlPoint.Set(	std::cos(rMath::DegreeToRad(theta + thetaStep)) * std::cos(rMath::DegreeToRad(phi)),
								std::cos(rMath::DegreeToRad(theta + thetaStep)) * std::sin(rMath::DegreeToRad(phi)),
								std::sin(rMath::DegreeToRad(theta + thetaStep)));
			spherePoints.push_back(controlPoint);


			controlPoint.Set(	std::cos(rMath::DegreeToRad(theta + thetaStep)) * std::cos(rMath::DegreeToRad(phi + phiStep)),
								std::cos(rMath::DegreeToRad(theta + thetaStep)) * std::sin(rMath::DegreeToRad(phi + phiStep)),
								std::sin(rMath::DegreeToRad(theta + thetaStep)));
			spherePoints.push_back(controlPoint);

			if (theta >= -90.0f && theta < 90.0f){
				controlPoint.Set(	std::cos(rMath::DegreeToRad(theta)) * std::cos(rMath::DegreeToRad(phi + phiStep)),
									std::cos(rMath::DegreeToRad(theta)) * std::sin(rMath::DegreeToRad(phi + phiStep)),
									std::sin(rMath::DegreeToRad(theta)));
				spherePoints.push_back(controlPoint);

				wireSphereIndicies.push_back(index);
				wireSphereIndicies.push_back(index + 1);

				wireSphereIndicies.push_back(index + 1);
				wireSphereIndicies.push_back(index + 2);

				wireSphereIndicies.push_back(index +2);
				wireSphereIndicies.push_back(index +3);

				wireSphereIndicies.push_back(index + 3);
				wireSphereIndicies.push_back(index);
				index += 4;
			}
			else{
				wireSphereIndicies.push_back(index);
				wireSphereIndicies.push_back(index + 1);

				wireSphereIndicies.push_back(index + 1);
				wireSphereIndicies.push_back(index + 2);

				wireSphereIndicies.push_back(index +2);
				wireSphereIndicies.push_back(index);
				index += 3;
			}
		}

	}


	sphereDrawPoints.resize(spherePoints.size());
}

void rGraphicsDevice::SetSphereDrawPoints(const rSphere3& s){
	for (size_t i = 0; i < spherePoints.size(); i++){
		sphereDrawPoints[i] = spherePoints[i] * s.radius;
		sphereDrawPoints[i] += s.center;
	}

}

void rGraphicsDevice::InitCone(){
	coneDrawPoints.resize(rqtCONE_SEGMENTS + 1);
	//coneIndicies.resize(rqtCONE_SEGMENTS + 1);

        for (unsigned int i = 0; i <= rqtCONE_SEGMENTS ;i++)
            coneIndicies.push_back(i);

        coneIndicies.push_back(1);
}

void rGraphicsDevice::SetConeDrawPoints(const rCone3& cone){
	rVector3 base = cone.Base();
	float radius = cone.CapRadius();

	float step = 360.0 / float(rqtCONE_SEGMENTS);
	float theta = 0;
	float radians;
        rMatrix4 xform;
        xform.SetRotationBetweenVectors(rVector3::DownVector , -cone.direction);
        xform.SetTranslate(base);
	coneDrawPoints[0] = cone.point;
	
	for (size_t i = 1; i <=rqtCONE_SEGMENTS; i++){
		radians = rMath::DegreeToRad(theta);
		
		coneDrawPoints[i].Set( std::cos(radians) * radius, 0.0f , std::sin(radians) * radius);
                xform.TransformVector3(coneDrawPoints[i]);

		theta += step;
	}


}

void rGraphicsDevice::InitBox(){
	boxPoints.resize(8);
	
	unsigned short indicies []= {0,1,1,2,2,3,3,0,1,5,2,6,0,4,3,7,4,5,5,6,6,7,7,4};
	wireBoxIndicies.resize(sizeof(indicies) / 2);

	for (size_t i = 0 ; i < wireBoxIndicies.size(); i++)
		wireBoxIndicies[i] = indicies[i];
		
}

void rGraphicsDevice::InitCircle(){
	int numCirclePoints = rqtCIRCLE_SEGMENTS + 1;
	float step = 360.0 / float(rqtCIRCLE_SEGMENTS);
	float theta = 0;
	float radians;

	circlePoints.resize( numCirclePoints);
	circleDrawPoints.resize( numCirclePoints);

	circlePoints[0] = rVector2::ZeroVector;

	for (size_t i = 1; i <=rqtCIRCLE_SEGMENTS; i++){
		radians = rMath::DegreeToRad(theta);
		circlePoints[i].Set(std::cos(radians) , std::sin(radians));
		theta += step;
	}

	for (unsigned short i = 0; i < rqtCIRCLE_SEGMENTS; i++){
		shadedCircleIndicies.push_back(0);
		shadedCircleIndicies.push_back(i+1);

		if (i == rqtCIRCLE_SEGMENTS-1)
			shadedCircleIndicies.push_back(1);
		else
			shadedCircleIndicies.push_back(i+2);
	}

	for (unsigned short i = 1; i <= rqtCIRCLE_SEGMENTS; i++)
		wireCircleIndicies.push_back(i);
}

void rGraphicsDevice::InitRectangle(){
	unsigned short shadedRectIndex[] = {0,1,2,3};
	unsigned short wireRectIndex[] = {0,1,3,2};

	shadedRectangleIndicies.insert(shadedRectangleIndicies.end(), shadedRectIndex , &shadedRectIndex[4]);
	wireRectangleIndicies.insert(wireRectangleIndicies.end() , wireRectIndex , &wireRectIndex[4]);

	rectanglePoints.resize(4);
}




void rGraphicsDevice::SetRectDrawPoints(const rRectangle2& r){
	rectanglePoints[0] = r.TopLeft();
	rectanglePoints[1] = r.BottomLeft();
	rectanglePoints[2] = r.TopRight();
	rectanglePoints[3] = r.BottomRight();
}



void rGraphicsDevice::SetBoxDrawPoints(const rAlignedBox3& b){
	boxPoints[0].Set(b.min.x , b.max.y , b.max.z);
	boxPoints[1] = b.max;
	boxPoints[2].Set(b.max.x , b.min.y , b.max.z);
	boxPoints[3].Set(b.min.x , b.min.y, b.max.z);

	boxPoints[4].Set(b.min.x , b.max.y , b.min.z);
	boxPoints[5].Set(b.max.x , b.max.y , b.min .z);
	boxPoints[6].Set(b.max.x , b.min.y , b.min.z);
	boxPoints[7] = b.min;
}

void rGraphicsDevice::SetCircleDrawPoints(const rCircle2& c){
	for (size_t i = 0; i < circlePoints.size(); i++){
		circleDrawPoints[i] = circlePoints[i] * c.radius;
		circleDrawPoints[i] += c.center;
	}
}